// src/api/auth.ts

/**
 * Mirrors auth routes. OAuth "start" endpoints are navigations, not XHR
 */

import { deleteRequest, postRequest } from "./http";

export const AuthAPI = {
  /**
   * POST /api/auth/register -> { id }
   */
  register: (email: string, pseudo: string, password: string) => {
    return postRequest<{ id: number }>("/api/auth/register", { email, pseudo, password });
  },

  /**
   * POST /api/auth/login -> { success: true } or { require2FA: true }
   */
  login: (pseudoOrEmail: string, password: string) => {
    return postRequest<{ success?: true; require2FA?: true }>("/api/auth/login", { pseudoOrEmail, password });
  },

  /**
   * POST /api/auth/logout -> { success: true }
   */
  logout: () => {
    return postRequest<{ success: true }>("/api/auth/logout");
  },

  /**
   * OAuth : Backend OAuth API (start functions) are browser navigations
   * because backend issues a 302 redirection
   */
  startGithubOAuth: () => {
    window.location.assign("/api/auth/oauth/github/start");
  },

  startGoogleOAuth: () => {
    window.location.assign("/api/auth/oauth/google/start");
  },

  start42OAuth: () => {
    window.location.assign("/api/auth/oauth/42/start");
  },

  /**
   * POST /api/auth/2fa/login -> { success: true }
   */
  verify2faLogin: (code: string) => {
    return postRequest<{ success: true }>("/api/auth/2fa/login", { code });
  },

  /**
   * POST /api/auth/2fa/setup -> { otpauth, qrDataUrl }
   */
  begin2fa: () => {
    return postRequest<{ otpauth: string; qrDataUrl: string }>("/api/auth/2fa/setup");
  },

  /**
   * POST /api/auth/2fa/verify -> { success: true }
   */
  verify2faSetup: (code: string) => {
    return postRequest<{ success: true }>("/api/auth/2fa/verify", { code });
  },

  /**
   * DELETE /api/auth/2fa -> { success: true }
   */
  disable2fa: () => {
    return deleteRequest<{ success: true }>("/api/auth/2fa");
  },
};
// src/api/chats.ts
import { getRequest, postRequest } from "./http";
import type { ChatListItem, Message, PublicUser } from "./types";

export const ChatsAPI = {
  /**
   * GET /api/chats?limit&offset -> { chats, limit, offset }
   */
  listMyChats: (limit = 50, offset = 0) => {
    return getRequest<{ chats: ChatListItem[]; limit: number; offset: number }>("/api/chats", { limit, offset });
  },

  /**
   * GET /api/chats/:chatId/messages?limit&offset -> { chatId, messages, limit, offset }
   */
  getMessages: (chatId: number, limit = 50, offset = 0) => {
    return getRequest<{ chatId: Number; messages: Message[]; limit: number; offset: number }>(`/api/chats/${chatId}/messages`, { limit, offset });
  },

  /**
   * POST /api/chats/:chatId/messages (body : {body}) -> Message
   */
  sendMessage: (chatId: number, body: string) => {
    return postRequest<Message>(`/api/chats/${chatId}/messages`, { body });
  },

  /**
   * POST /api/chats/with/:userId -> { id, peer }
   */
  ensureChatWithUser: (userId: number) => {
    return postRequest<{ id: number; peer: PublicUser }>(`/api/chats/with/${userId}`);
  },

  /**
   * POST /api/chats/with/:userId/messages (body: { body }) -> Message
   */
  ensureChatAndSend: (userId: number, body: string) => {
    return postRequest<Message>(`/api/chats/with/${userId}/messages`, { body });
  },
};
// src/api/friends.ts

import { getRequest, postRequest, putRequest, deleteRequest } from "./http";
import type { PublicUser, FriendRequest } from "./types";

export const FriendsAPI = {
  /**
   * GET /api/friends -> { friends }
   */
  listFriends: () => {
    return getRequest<{ friends: PublicUser[] }>("/api/friends");
  },

  /**
   * GET /api/friends/requests -> { friendRequests }
   */
  listFriendRequests: () => {
    return getRequest<{ friendRequests: FriendRequest[] }>("/api/friends/requests");
  },

  /**
   * POST /api/friends/requests -> { id } (body: {to_user_id})
   */
  sendRequest: (toUserId: number) => {
    return postRequest<{ id: number }>("/api/friends/requests", { to_user_id: toUserId });
  },

  /**
   * PUT /api/friends/:requestId -> { success: true }
   */
  acceptRequest: (requestId: number) => {
    return putRequest<{ success: true }>(`/api/friends/requests/${requestId}`);
  },

  /**
   * DELETE /api/friends/requests/:requestId -> { success: true }
   */
  declineRequest: (requestId: number) => {
    return deleteRequest<{ success: true }>(`/api/friends/requests/${requestId}`);
  },

  /**
   * DELETE /api/friends/:friendId -> { success: true }
   */
  removeFriend: (friendId: number) => {
    return deleteRequest<{ success: true }>(`/api/friends/${friendId}`);
  },
};
// src/api/http.ts

/**
 * Centralized fetch wrapper :
 * - sets base URL (env overrideable)
 * - alway ssends cookies (session JWT)
 * - normalizes JSON parsing and errors
 * - tiny helpers for query strings and JSON bodies
 */

/**
 * In dev we can leave this empty and rely on Vite proxy
 * In prod, set VITE_API_BASE to the domain
 */
export const API_BASE = (import.meta as any)?.env?.VITE_API_BASE ?? "";

export class HttpError extends Error {
  constructor(public status: number, message: string, public body?: unknown) {
    super(message);
    this.name = "HttpError";
  }
}

/**
 * Build a query string from an object, skipping null/undefined
 */
export function queryString(params?: Record<string, any>): string {
  if (!params) return "";
  const entries = Object.entries(params)
    .filter(([, v]) => v != undefined && v != null)
    .map(([k, v]) => [k, String(v)]);

  return entries.length ? "?" + new URLSearchParams(entries) : "";
}

/**
 * Low-level abstracted function. Called by Http Methods helpers below
 */
export async function http<T = unknown>(path: string, init: RequestInit = {}): Promise<T> {
  const res = await fetch(API_BASE + path, {
    // Cookie-based session from backend
    credentials: "include",
    // Default headers, potentially overriden
    headers: { Accept: "application/json", ...(init.headers || {}) },
    ...init,
  });

  // Try to parse JSON; tolerate empty bodies or non-JSON errors
  const text = await res.text();

  function textToJSON(text: string) {
    try {
      return JSON.parse(text);
    } catch {
      return text;
    }
  }

  const data = text ? textToJSON(text) : null;

  if (!res.ok) {
    const message = (data && typeof data === "object" && (data as any).message) || (data && typeof data === "object" && (data as any).error) || res.statusText;
    throw new HttpError(res.status, String(message || "HTTP error"), data ?? undefined);
  }
  return data as T;
}

export function getRequest<T>(path: string, params?: Record<string, any>) {
  return http<T>(path + queryString(params), { method: "GET" });
}

export function postRequest<T>(path: string, json?: any) {
  return http<T>(path, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: json !== undefined ? JSON.stringify(json) : undefined,
  });
}

export function putRequest<T>(path: string, json?: any) {
  return http<T>(path, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: json !== undefined ? JSON.stringify(json) : undefined,
  });
}

export function deleteRequest<T>(path: string) {
  return http<T>(path, { method: "DELETE" });
}
// src/api/matches.ts
import { getRequest, postRequest, putRequest } from "./http";
import type { Match } from "./types";

export const MatchesAPI = {
  /**
   * POST /api/matches (body: { opponentId }) -> Match
   */
  create: (opponentId: number) => {
    return postRequest<Match>("/api/matches", { opponentId });
  },

  /**
   * GET /api/matches/:matchId -> Match
   */
  get: (matchId: number) => {
    return getRequest<Match>(`/api/matches/${matchId}`);
  },

  /**
   * PUT /api/matches/:matchId/result (body: { scoreP1, scoreP2 }) -> Match
   */
  recordResult: (matchId: number, scoreP1: number, scoreP2: number) => {
    return putRequest<Match>(`/api/matches/${matchId}`, { scoreP1, scoreP2 });
  },

  /**
   * PUT /api/matches/:matchId/cancel -> Match
   */
  cancel: (matchId: number) => {
    return putRequest<Match>(`/api/matches/${matchId}/cancel`);
  },
};
// src/api/tournaments.ts
import { getRequest, postRequest, putRequest } from "./http";
import type { Tournament, TournamentDetails } from "./types";

export const TournamentsAPI = {
  /**
   * GET /api/tournaments?limit&offset -> { tournaments, limit, offset }
   */
  listTournaments: (limit = 50, offset = 0) => {
    return getRequest<{ tournaments: Tournament[]; limit: number; offset: number }>("/api/tournaments", { limit, offset });
  },

  /**
   * POST /api/tournaments -> Tournament
   */
  createTournament: (title: string, description: string | null = null, maxPlayers = 8) => {
    return postRequest<Tournament>("/api/tournaments", { title, description, maxPlayers });
  },

  /**
   * GET /api/tournaments/:tournamentId -> Tournament Details
   */
  getDetails: (tournamentId: number) => {
    return getRequest<TournamentDetails>(`/api/tournaments/${tournamentId}`);
  },

  /**
   * POST /api/tournaments/:tournamentId/join -> { success: true}
   */
  joinTournament: (tournamentId: number) => {
    return postRequest<{ success: true }>(`/api/tournaments/${tournamentId}/join`);
  },

  /**
   * PUT /api/tournaments/:matchId/result (body: { scoreP1, scoreP2 }) -> updated match (backend returns "updated")
   */
  recordMatchResult: (matchId: number, scoreP1: number, scoreP2: number) => {
    return putRequest<any>(`/api/tournaments/${matchId}/result`, { scoreP1, scoreP2 });
  },
};
// src/api/types.ts
/**
 * Lightweight shapes matching the backend controllers' responses
 */

export type Me = {
  id: number;
  email: string;
  pseudo: string;
  avatar_url: string | null;
};

export type PublicUser = {
  id: number;
  pseudo: string;
  avatar_url: string | null;
};

export type FriendRequest = {
  id: number;
  from_user_id: number;
  to_user_id: number;
  created_at: string;
};

export type ChatPeer = PublicUser;

export type ChatListItem = {
  id: number;
  created_at: string;
  peer: ChatPeer;
  last_message: null | {
    id: number;
    author_id: number;
    body: string;
    created_at: string;
  };
};

export type Message = {
  id: number;
  chat_id: number;
  author_id: number;
  body: string;
  created_at: string;
};

export type Match = {
  id: number;
  player1_id: number;
  player2_id: number;
  status: "pending" | "completed" | "canceled";
  winner_id: number | null;
  score_P1: number | null;
  score_P2: number | null;
  created_at: string;
};

export type Tournament = {
  id: number;
  owner_id: number;
  title: string;
  description: string | null;
  max_players: number;
  status: "registration" | "running" | "completed";
  created_at: string;
};

export type TournamentDetails = {
  tournament: Tournament;
  participants: { user_Id: number }[];
};
// src/api/users.ts
import { getRequest, putRequest, deleteRequest } from "./http";
import type { Me, PublicUser, Match } from "./types";

export const UsersAPI = {
  /**
   * GET /api/users/me -> current user
   */
  me: () => getRequest<Me>("/api/users/me"),

  /**
   * PUT /api/users/me -> update pseudo and/or avatar_url
   */
  updateMe: (input: { pseudo?: string; avatar_url?: string | null }) => {
    return putRequest<Me>("/api/users/me", input);
  },

  /**
   * PUT /api/users/me/avatar -> set/replace avatar (url based in the backend)
   */
  uploadAvatar: (avatar_url: string) => {
    return putRequest<Me>("/api/users/me", { avatar_url });
  },

  /**
   * DELETE /api/users/me/avatar
   */
  deleteAvatar: () => deleteRequest<Me>("/api/users/me/avatar"),

  /**
   * GET /api/users/:id -> public profile
   */
  getPublic: (userId: number) => getRequest<PublicUser>(`/api/users/${userId}`),

  /**
   * GET /api/users/:id/matches?limit&offset -> { matches, limit offset }
   */
  listUserMatches: (userId: number, limit = 50, offset = 0) => {
    return getRequest<{ matches: Match[]; limit: number; offset: number }>(`/api/users/${userId}/matches`, { limit, offset });
  },

  /**
   * GET /api/users/search?q&limit&offset -> { users, limit, offset }
   */
  searchUser: (q: string, limit = 20, offset = 0) => {
    return getRequest<{ users: PublicUser[]; limit: number; offset: number }>(`/api/users/search`, { q, limit, offset });
  },
};
// src/router/router.ts
import type { View } from "../views/AppShell";
import type { Route } from "./routes";

export type NavigationTarget = {
  route: Route;
  params: Record<string, string>;
  fullPath: string;
};

export type RouterOptions = {
  defaultPath?: string;
  onBeforeEach?: (to: NavigationTarget) => void | Promise<void>;
  onAfterEach?: (to: NavigationTarget) => void | Promise<void>;
};

export class Router {
  private routes: Route[];
  private options: RouterOptions;
  private outlet: HTMLElement;
  private currentUnmount: (() => void) | null = null;
  private onHashChangeBound: () => void;

  constructor(routes: Route[], outletSelector = "#app", options: RouterOptions = {}) {
    const outlet = document.querySelector(outletSelector);
    if (!outlet) throw new Error(`Router outlet "${outletSelector}" not found`);
    this.routes = routes;
    this.options = options;
    this.outlet = outlet as HTMLElement;
    this.onHashChangeBound = this.render.bind(this);
  }

  start() {
    if (!location.hash) {
      this.navigate(this.options.defaultPath || "/login");
    }
    window.addEventListener("hashchange", this.onHashChangeBound);
    void this.render();
  }

  dispose() {
    window.removeEventListener("hashchange", this.onHashChangeBound);
    this.unmountCurrent();
  }

  navigate(path: string) {
    location.hash = path.startsWith("#") ? path : `#${path}`;
  }

  renderNow() {
    return this.render();
  }

  setRoutes(routes: Route[]) {
    this.routes = routes;
    return this.render();
  }

  private unmountCurrent() {
    if (this.currentUnmount) {
      try {
        this.currentUnmount();
      } catch {}
      this.currentUnmount = null;
    }
  }

  private pathToRegex(path: string): RegExp {
    return new RegExp("^" + path.replace(/:[^/]+/g, "([^/]+)") + "$");
  }

  private extractParams(path: string, match: RegExpExecArray): Record<string, string> {
    const keys = (path.match(/:([^/]+)/g) || []).map((k) => k.slice(1));
    const values = match.slice(1);
    const params: Record<string, string> = {};
    keys.forEach((k, i) => (params[k] = values[i]));
    return params;
  }

  private matchRoute(path: string): NavigationTarget | null {
    for (const r of this.routes) {
      const rx = this.pathToRegex(r.path);
      const result = rx.exec(path);
      if (result) {
        return {
          route: r,
          params: this.extractParams(r.path, result),
          fullPath: path,
        };
      }
    }
    return null;
  }

  private async render() {
    const raw = (location.hash || "").replace(/^#/, "");
    const path = raw || this.options.defaultPath || "/login";

    const matched = this.matchRoute(path) ?? this.matchRoute(this.options.defaultPath || "/login");

    if (!matched) {
      this.outlet.replaceChildren();
      this.currentUnmount = null;
      return;
    }

    if (this.options.onBeforeEach) {
      await this.options.onBeforeEach(matched);
    }

    this.unmountCurrent();
    this.outlet.replaceChildren();
    this.currentUnmount = matched.route.view(this.outlet, matched.params);

    if (this.options.onAfterEach) {
      await this.options.onAfterEach(matched);
    }

    window.scrollTo(0, 0);
  }
}
// src/router/routes.ts
import type { View } from "../views/AppShell";
import { LoginView } from "../views/LoginView";
import { AppShell } from "../views/AppShell";
import { HomeView } from "../views/HomeView";
import { ProfileView } from "../views/ProfileView";
import { FriendsView } from "../views/FriendsView";
import { ChatsView } from "../views/ChatsView";
import { TournamentsView } from "../views/TournamentsView";
import { auth } from "../store/auth";

export type Route = {
  path: string;
  view: View;
  auth?: boolean;
};

export const Routes: Route[] = [
  { path: "/login", view: LoginView, auth: false },
  { path: "/play", view: AppShell(HomeView), auth: true },
  { path: "/leaderboard", view: AppShell(HomeView), auth: true },
  { path: "/profile", view: AppShell(ProfileView), auth: true },
  { path: "/chats", view: AppShell(ChatsView), auth: true },
  { path: "/tournaments", view: AppShell(TournamentsView), auth: true },
];

export async function guard({ route }: { route: Route }) {
  const s = auth.get();
  if (s.loading) return;
  if (route.auth && !s.me) location.hash = "/login";
  if (!route.auth && route.path === "/login" && s.me) location.hash = "/profile";
}
// src/store/auth.ts
import { createStore } from "./createStore";
import { AuthAPI } from "../api/auth";
import { UsersAPI } from "./../api/users";
import type { Me } from "../api/types";
import { HttpError } from "../api/http";

/**
 *
 */
export type AuthState = {
  me: Me | null;
  loading: boolean;
  twofaRequired: boolean;
  error: string | null;
};

export const auth = createStore<AuthState>({
  me: null,
  loading: true,
  twofaRequired: false,
  error: null,
});

/**
 * Bootstrap session from cookie
 */
export async function bootstrapSession() {
  auth.set((s) => ({ ...s, loading: true, error: null }));
  try {
    const me = await UsersAPI.me();
    auth.set((s) => ({ ...s, me: me, loading: false }));
  } catch {
    auth.set((s) => ({ ...s, me: null, loading: false }));
  }
}

/**
 * Register
 */
export async function register(email: string, pseudo: string, password: string) {
  return await AuthAPI.register(email, pseudo, password);
}

/**
 * Username/password login (may require 2FA)
 */
export async function login(pseudoOrEmail: string, password: string) {
  auth.set((s) => ({ ...s, error: null }));
  try {
    const res = await AuthAPI.login(pseudoOrEmail, password);
    if (res?.require2FA) {
      auth.set((s) => ({ ...s, twofaRequired: true }));
      return;
    }
    const me = await UsersAPI.me();
    auth.set((s) => ({ ...s, me: { ...me, avatar_url: me.avatar_url ?? "/user.png" }, twofaRequired: false }));
  } catch (e: any) {
    const msg = e instanceof HttpError ? `${e.status}: ${e.message}` : "Login failed";
    auth.set((s) => ({ ...s, error: msg, me: null, twofaRequired: false }));
    throw e;
  }
}

/**
 * Logout (ignore networks problems; clear local state regardless)
 */
export async function logout() {
  try {
    await AuthAPI.logout();
  } catch {}
  auth.set((s) => ({ ...s, me: null, twofaRequired: false }));
  location.hash = "/login";
}

/**
 * Complete a pending 2FA login
 */
export async function verify2faLogin(code: string) {
  await AuthAPI.verify2faLogin(code);
  const me = await UsersAPI.me();
  auth.set((s) => ({ ...s, me, twofaRequired: false }));
}

/**
 * Begin 2FA enrollment (returns otpauth + QR) for UI to show
 */
export async function begin2fa() {
  return await AuthAPI.begin2fa();
}

/**
 * Verify 2FA setup code the user types
 */
export async function verify2faSetup(code: string) {
  await AuthAPI.verify2faSetup(code);
}

/**
 * Disable 2FA
 */
export async function disable2fa() {
  await AuthAPI.disable2fa();
}
// src/store/chats.ts
import { createStore } from "./createStore";
import { ChatsAPI } from "../api/chats";
import type { ChatListItem, Message } from "../api/types";

export type ChatsState = {
  loading: boolean;
  list: ChatListItem[];
  limit: number;
  offset: number;

  messages: Record<number, { loading: boolean; items: Message[]; limit: number; offset: number }>;
  sending: Record<number, boolean>;
  error: string | null;
};

export const chats = createStore<ChatsState>({
  loading: false,
  list: [],
  limit: 50,
  offset: 0,
  messages: {},
  sending: {},
  error: null,
});

// Helpers
function ensureMsgBucket(state: ChatsState, chatId: number) {
  if (!state.messages[chatId]) {
    state.messages[chatId] = { loading: false, items: [], limit: 50, offset: 0 };
  }
}

// Actions
export async function loadMyChats(limit = 50, offset = 0) {
  chats.set((s) => ({ ...s, loading: true, error: null }));
  try {
    const res = await ChatsAPI.listMyChats(limit, offset);
    chats.set((s) => ({ ...s, list: res.chats, limit: res.limit, offset: res.offset, loading: false }));
  } catch (e: any) {
    chats.set((s) => ({ ...s, loading: false, error: e?.message ?? "Failed to load chats" }));
  }
}

export async function loadMessages(chatId: number, limit = 50, offset = 0) {
  chats.set((s) => {
    const copy = { ...s };
    ensureMsgBucket(copy, chatId);
    copy.messages[chatId] = { ...copy.messages[chatId], loading: true };
    return copy;
  });
  try {
    const res = await ChatsAPI.getMessages(chatId, limit, offset);
    chats.set((s) => {
      const copy = { ...s };
      ensureMsgBucket(copy, chatId);
      copy.messages[chatId] = {
        loading: false,
        limit: res.limit,
        offset: res.offset,
        items: res.messages,
      };
      return copy;
    });
  } catch (e: any) {
    chats.set((s) => {
      const copy = { ...s };
      ensureMsgBucket(copy, chatId);
      copy.messages[chatId] = { ...copy.messages[chatId], loading: false };
      copy.error = e?.message ?? "Failed to load messages";
      return copy;
    });
  }
}

export async function sendMessage(chatId: number, body: string) {
  chats.set((s) => ({ ...s, sending: { ...s.sending, [chatId]: true } }));
  try {
    const msg = await ChatsAPI.sendMessage(chatId, body);
    chats.set((s) => {
      const copy = { ...s };
      ensureMsgBucket(copy, chatId);
      copy.messages[chatId] = {
        ...copy.messages[chatId],
        items: [...copy.messages[chatId].items, msg],
      };
      // Also refresh the chat list last_message field for this chatId
      copy.list = copy.list.map((c) => (c.id === chatId ? { ...c, last_message: { id: msg.id, author_id: msg.author_id, body: msg.body, created_at: msg.created_at } } : c));
      copy.sending = { ...copy.sending, [chatId]: false };
      return copy;
    });
  } catch (e: any) {
    chats.set((s) => ({ ...s, sending: { ...s.sending, [chatId]: false } }));
    throw e;
  }
}

export async function ensureChatWith(userId: number) {
  const { id, peer } = await ChatsAPI.ensureChatWithUser(userId);

  // Merge chat into list if missing
  chats.set((s) => {
    if (s.list.some((c) => c.id === id)) return s;
    return { ...s, list: [{ id, created_at: new Date().toISOString(), peer, last_message: null }, ...s.list] };
  });
  return id;
}

export async function ensureChatAndSend(userId: number, body: string) {
  const msg = await ChatsAPI.ensureChatAndSend(userId, body);

  chats.set((s) => {
    const copy = { ...s };
    const existing = copy.list.find((c) => c.id === msg.chat_id);
    if (!existing) {
      // We don't know peer data here; safest is to refresh chat list outside or ensureChatWith first
      copy.list = [{ id: msg.chat_id, created_at: msg.created_at, peer: { id: userId, pseudo: "(loading...)", avatar_url: null }, last_message: null }, ...copy.list];
    }
    ensureMsgBucket(copy, msg.chat_id);
    copy.messages[msg.chat_id].items = [...copy.messages[msg.chat_id].items, msg];
    return copy;
  });

  return msg;
}
// src/store/createStore.ts

/**
 * A listener has no arguments : when state changes, it just re-renders
 */
type Listener = () => void;

/**
 * Returns a minimalist state container with get, set and subscribe
 */
export function createStore<S>(initial: S) {
  let state = initial;
  const listeners = new Set<Listener>();

  return {
    get(): S {
      return state;
    },

    /**
     * Takes a pure function as a parameter to compute next state from current state
     */
    set(updater: (s: S) => S | void): void {
      const next = updater(state) ?? state;
      if (next !== state) {
        state = next as S;
        listeners.forEach((l) => l());
      }
    },

    /**
     * Adds a function to the set of listeners
     * Returns a function to unsubscribe from the set of listeners
     */
    subscribe(fn: Listener): () => void {
      listeners.add(fn);
      return () => listeners.delete(fn);
    },
  };
}
// src/store/friends.ts
import { createStore } from "./createStore";
import { FriendsAPI } from "../api/friends";
import type { PublicUser, FriendRequest } from "../api/types";

export type FriendsState = {
  loading: boolean;
  friends: PublicUser[];
  requestsLoading: boolean;
  requests: FriendRequest[];
  error: string | null;
};

export const friends = createStore<FriendsState>({
  loading: false,
  friends: [],
  requestsLoading: false,
  requests: [],
  error: null,
});

export async function loadFriends() {
  friends.set((s) => ({ ...s, loading: true, error: null }));
  try {
    const res = await FriendsAPI.listFriends();
    friends.set((s) => ({ ...s, friends: res.friends, loading: false }));
  } catch (e: any) {
    friends.set((s) => ({ ...s, loading: false, error: e?.message ?? "Failed to load friends" }));
  }
}

export async function loadFriendRequests() {
  friends.set((s) => ({ ...s, requestsLoading: true, error: null }));
  try {
    const res = await FriendsAPI.listFriendRequests();
    friends.set((s) => ({ ...s, requests: res.friendRequests, requestsLoading: false }));
  } catch (e: any) {
    friends.set((s) => ({ ...s, requestsLoading: false, error: e?.message ?? "Failed to load requests" }));
  }
}

export async function sendFriendRequest(toUserId: number) {
  await FriendsAPI.sendRequest(toUserId);
  await Promise.allSettled([loadFriends(), loadFriendRequests()]);
}

export async function acceptFriendRequest(requestId: number) {
  friends.set((s) => ({ ...s, requests: s.requests.filter((r) => r.id !== requestId) }));
  try {
    await FriendsAPI.acceptRequest(requestId);
    await loadFriends();
  } catch (e: any) {
    await loadFriendRequests();
    throw e;
  }
}

export async function declineFriendRequest(requestId: number) {
  friends.set((s) => ({ ...s, requests: s.requests.filter((r) => r.id !== requestId) }));
  try {
    await FriendsAPI.declineRequest(requestId);
  } catch (e: any) {
    await loadFriendRequests();
    throw e;
  }
}

export async function removeFriends(friendId: number) {
  friends.set((s) => ({ ...s, friends: s.friends.filter((f) => f.id !== friendId) }));
  try {
    await FriendsAPI.removeFriend(friendId);
  } catch (e: any) {
    await loadFriends();
    throw e;
  }
}
// src/store/matches.ts
import { createStore } from "./createStore";
import { MatchesAPI } from "../api/matches";
import type { Match } from "../api/types";

export type MatchesState = {
  byId: Record<number, Match>;
  loading: Record<number, boolean>;
  creating: boolean;
  error: string | null;
};

export const matches = createStore<MatchesState>({
  byId: {},
  loading: {},
  creating: false,
  error: null,
});

export async function createMatch(opponentId: number) {
  matches.set((s) => ({ ...s, creating: true, error: null }));
  try {
    const match = await MatchesAPI.create(opponentId);
    matches.set((s) => ({ ...s, byId: { ...s.byId, [match.id]: match }, creating: false }));
    return match;
  } catch (e: any) {
    matches.set((s) => ({ ...s, creating: false, error: e?.message ?? "Failed to create match" }));
    throw e;
  }
}

export async function loadMatch(matchId: number) {
  matches.set((s) => ({ ...s, loading: { ...s.loading, [matchId]: true } }));
  try {
    const match = await MatchesAPI.get(matchId);
    matches.set((s) => ({ ...s, byId: { ...s.byId, [matchId]: match }, loading: { ...s.loading, [matchId]: false } }));
  } catch {
    matches.set((s) => ({ ...s, loading: { ...s.loading, [matchId]: false } }));
  }
}

export async function recordResult(matchId: number, scoreP1: number, scoreP2: number) {
  const match = await MatchesAPI.recordResult(matchId, scoreP1, scoreP2);
  matches.set((s) => ({ ...s, byId: { ...s.byId, [matchId]: match } }));
  return match;
}

export async function cancelMatch(matchId: number) {
  const match = await MatchesAPI.cancel(matchId);
  matches.set((s) => ({ ...s, byId: { ...s.byId, [matchId]: match } }));
  return match;
}
// src/store/tournaments.ts
import { createStore } from "./createStore";
import { TournamentsAPI } from "../api/tournaments";
import type { Tournament, TournamentDetails } from "../api/types";

export type TournamentsState = {
  listing: {
    loading: boolean;
    items: Tournament[];
    limit: number;
    offset: number;
    error: string | null;
  };
  byId: Record<number, TournamentDetails>;
  loadingDetails: Record<number, boolean>;
  creating: boolean;
};

export const tournaments = createStore<TournamentsState>({
  listing: {
    loading: false,
    items: [],
    limit: 50,
    offset: 0,
    error: null,
  },
  byId: {},
  loadingDetails: {},
  creating: false,
});

export async function listTournaments(limit = 50, offset = 0) {
  tournaments.set((s) => ({
    ...s,
    listing: {
      ...s.listing,
      loading: true,
      error: null,
    },
  }));

  try {
    const res = await TournamentsAPI.listTournaments(limit, offset);
    tournaments.set((s) => ({
      ...s,
      listing: {
        ...s.listing,
        loading: false,
        items: res.tournaments,
        limit: res.limit,
        offset: res.offset,
      },
    }));
  } catch (e: any) {
    tournaments.set((s) => ({
      ...s,
      listing: {
        ...s.listing,
        loading: false,
        error: e?.message ?? "Failed to load tournaments",
      },
    }));
  }
}

export async function createTournament(title: string, description: string | null, maxPlayers = 8) {
  tournaments.set((s) => ({
    ...s,
    creating: true,
  }));

  try {
    const tournament = await TournamentsAPI.createTournament(title, description, maxPlayers);
    tournaments.set((s) => ({
      ...s,
      creating: false,
      listing: {
        ...s.listing,
        items: [tournament, ...s.listing.items],
      },
    }));
    return tournament;
  } finally {
    tournaments.set((s) => ({
      ...s,
      creating: false,
    }));
  }
}

export async function loadTournamentDetails(tournamentId: number) {
  tournaments.set((s) => ({
    ...s,
    loadingDetails: { ...s.loadingDetails, [tournamentId]: true },
  }));

  try {
    const details = await TournamentsAPI.getDetails(tournamentId);
    tournaments.set((s) => ({
      ...s,
      byId: {
        ...s.byId,
        [tournamentId]: details,
      },
      loadingDetails: {
        ...s.loadingDetails,
        [tournamentId]: false,
      },
    }));
  } catch {
    tournaments.set((s) => ({
      ...s,
      loadingDetails: {
        ...s.loadingDetails,
        [tournamentId]: false,
      },
    }));
  }
}

export async function joinTournament(tournamentId: number) {
  await TournamentsAPI.joinTournament(tournamentId);
  // Refresh details so participants list is up to date
  await loadTournamentDetails(tournamentId);
}

export async function recordTournamentMatchResult(matchId: number, scoreP1: number, scoreP2: number) {
  return await TournamentsAPI.recordMatchResult(matchId, scoreP1, scoreP2);
}
// src/store/users.ts
import { createStore } from "./createStore";
import { UsersAPI } from "../api/users";
import type { Me, PublicUser } from "../api/types";

export type UsersState = {
  meUpdating: boolean;
  search: {
    q: string;
    loading: boolean;
    results: PublicUser[];
    limit: number;
    offset: number;
  };
};

export const users = createStore<UsersState>({
  meUpdating: false,
  search: {
    q: "",
    loading: false,
    results: [],
    limit: 20,
    offset: 0,
  },
});

/**
 * Update current user
 */
export async function updateMe(input: { pseudo?: string; avatar_url?: string | null }) {
  users.set((s) => ({ ...s, meUpdating: true }));
  try {
    const me: Me = await UsersAPI.updateMe(input);
    const { auth } = await import("./auth");
    auth.set((s) => ({ ...s, me }));
  } finally {
    users.set((s) => ({ ...s, meUpdating: false }));
  }
}

/**
 * Uploading avatar
 */
export async function uploadAvatar(url: string) {
  users.set((s) => ({ ...s, meUpdating: true }));
  try {
    const me: Me = await UsersAPI.uploadAvatar(url);
    const { auth } = await import("./auth");
    auth.set((s) => ({ ...s, me }));
  } finally {
    users.set((s) => ({ ...s, meUpdating: false }));
  }
}

/**
 * Deleting avatar
 */
export async function deleteAvatar() {
  users.set((s) => ({ ...s, meUpdating: true }));
  try {
    const me: Me = await UsersAPI.deleteAvatar();
    const { auth } = await import("./auth");
    auth.set((s) => ({ ...s, me }));
  } finally {
    users.set((s) => ({ ...s, meUpdating: false }));
  }
}

/**
 * Simple search with paging
 */
export async function searchUsers(q: string, limit = 20, offset = 0) {
  users.set((s) => ({ ...s, search: { ...s.search, q, loading: true, limit, offset } }));
  try {
    const res = await UsersAPI.searchUser(q, limit, offset);
    users.set((s) => ({ ...s, search: { ...s.search, loading: false, results: res.users, limit: res.limit, offset: res.offset } }));
  } catch {
    users.set((s) => ({ ...s, search: { ...s.search, loading: false, results: [] } }));
  }
}
/* tailwind.css */
@import "tailwindcss";
// src/ui/Avatar.ts
import { domElem } from "./DomElement";

export function Avatar(url: string | null, size = 40) {
  const elem = domElem("div", {
    class: "rounded-full bg-gray-200 overflow-hidden flex-shrink-0",
    attributes: {
      style: `width:${size}px;height${size}px`,
    },
  });

  if (url) {
    const img = domElem("img", {
      class: "w-full h-full object-cover",
      attributes: {
        src: url,
        alt: "avatar",
      },
    });
    elem.appendChild(img);
  }

  return elem;
}
// src/ui/Button.ts
import { domElem } from "./DomElement";

export function Button(
  label: string,
  options: {
    onClick?: (e: MouseEvent) => void;
    variant?: "primary" | "ghost" | "danger" | "login" | "loginSmall" | "oauth";
    type?: "button" | "submit";
    leading?: HTMLElement | null;
  } = {}
) {
  const variants = {
    primary: "px-4 py-2 rounded-xl text-sm font-medium shadow-sm transition bg-indigo-600 text-white hover:bg-indigo-500",
    ghost: "px-4 py-2 rounded-xl text-sm font-medium shadow-sm transition bg-transparent text-indigo-600 hover:bg-indigo-50",
    danger: "px-4 py-2 rounded-xl text-sm font-medium shadow-sm transition bg-rose-600 text-white hover:bg-rose-500",
    login: "justify-center px-4 py-5 rounded-xl text-base font-semibold transition bg-indigo-900 hover:bg-indigo-700",
    loginSmall: "justify-center px-4 py-3 rounded-xl text-base font-semibold transition bg-indigo-900 hover:bg-indigo-700",
    oauth: "w-full justify-start px-4 py-5 rounded-xl text-base font-semibold transition bg-slate-800 hover:bg-slate-500",
  };

  const btn = domElem("button", {
    class: `inline-flex items-center gap-3 ${variants[options.variant ?? "primary"]}`,
    attributes: { type: options.type ?? "button" },
  });

  if (options.leading) {
    const iconSlot = domElem("span", { class: "shrink-0 grid place-items-center mr-4" });
    iconSlot.appendChild(options.leading);
    btn.appendChild(iconSlot);
  } else {
    btn.appendChild(domElem("span", { class: "shrink-0" }));
  }

  btn.appendChild(domElem("span", { text: label }));

  if (options.onClick) {
    btn.addEventListener("click", options.onClick);
  }
  return btn;
}

export function IconButton(faSrc: string, alt: string, onClick: () => void, title?: string) {
  const btn = domElem("button", {
    class: "rounded-xl p-2 hover:bg-slate-100 transition inline-grid place-items-center",
    attributes: { type: "button", title: title ?? alt, "aria-label": alt },
  });
  const logo = domElem("i", { class: `fa-solid ${faSrc}` });
  btn.appendChild(logo);
  btn.addEventListener("click", onClick);
  return btn;
}

export function ImageButton(
  imgSrc: string,
  alt: string,
  options: {
    onClick?: (e: MouseEvent) => void;
    size?: number; // px — defaults to 36
    variant?: "plain" | "ghost" | "circle"; // style flavors
    title?: string;
  } = {}
) {
  const { onClick, size = 36, variant = "plain", title } = options;

  const variants = {
    plain: "rounded-xl border border-gray-200 hover:bg-slate-100 transition",
    ghost: "rounded-xl hover:bg-slate-100 transition",
    circle: "rounded-full hover:ring-2 hover:ring-indigo-500 transition",
  };

  const btn = domElem("button", {
    class: `inline-grid place-items-center ${variants[variant]}`,
    attributes: {
      type: "button",
      title: title ?? alt,
      "aria-label": alt,
      style: `width:${size}px;height:${size}px;`,
    },
  });

  const img = domElem("img", {
    class: "w-full h-full object-contain",
    attributes: { src: imgSrc, alt },
  });

  btn.appendChild(img);
  if (onClick) btn.addEventListener("click", onClick);
  return btn;
}
// src/ui/Card.ts
import { domElem, mount } from "./DomElement";

export function Card(...children: (HTMLElement | string)[]) {
  const card = domElem("div", { class: "bg-white/70 backdrop-blur shadow rounded-2xl p-4 border border-gray-100" });
  mount(card, ...(children as HTMLElement[]));
  return card;
}
// src/ui/DomElement.ts

/**
 * DOM Elements factory
 */
export function domElem<K extends keyof HTMLElementTagNameMap>(
  tag: K,
  options: {
    class?: string;
    text?: string;
    attributes?: Record<string, string>;
    on?: Record<string, (e: Event) => void>;
  } = {}
): HTMLElementTagNameMap[K] {
  const node = document.createElement(tag);
  if (options.class) node.className = options.class;
  if (options.text) node.textContent = options.text;
  if (options.attributes) {
    for (const [k, v] of Object.entries(options.attributes)) {
      node.setAttribute(k, v);
    }
  }
  if (options.on) {
    for (const [k, fn] of Object.entries(options.on)) {
      node.addEventListener(k, fn);
    }
  }
  return node;
}

/**
 * Appends a list of children to the parent element passed as argument
 */
export function mount(parent: HTMLElement, ...children: (HTMLElement | string | null | undefined)[]) {
  children.filter(Boolean).forEach((c) => parent.append(c as any));
  return parent;
}

type Unsubscribe = () => void;

/**
 * Binder to the createStore function
 */
export function bind<S>(
  store: {
    subscribe: (fn: () => void) => Unsubscribe;
    get: () => S;
  },
  render: (state: S) => void
) {
  render(store.get());
  const unsub = store.subscribe(() => render(store.get()));
  return () => unsub();
}
// src/ui/Icons.ts
import { domElem } from "./DomElement";

export function Icon(srcPath: string, alt: string) {
  const icon = domElem("img", {
    class: "w-10 h-10 object-contain",
    attributes: { src: `${srcPath}`, alt },
  });
  return icon;
}
// src/ui/Input.ts
import { domElem, mount } from "./DomElement";

export function LabeledInput(label: string, options: { type?: string; name?: string; placeholder?: string; value?: string } = {}) {
  const labelWrapper = domElem("label", { class: "flex flex-col gap-2" });
  const span = domElem("span", { class: "text-sm text-gray-500", text: label });
  const input = domElem("input", {
    class: "px-3 py-2 rounded-xl border border-gray-200 focus:outline-none focus:ring-2 focus:ring-indigo-500",
    attributes: {
      type: options.type ?? "text",
      name: options.name ?? "",
      placeholder: options.placeholder ?? "",
      value: options.value ?? "",
    },
  });
  mount(labelWrapper, span, input);
  return { labelWrapper, input };
}
// src/views/AppShell.ts
import { domElem, mount, bind } from "../ui/DomElement";
import { Button, IconButton, ImageButton } from "../ui/Button";
import { Avatar } from "../ui/Avatar";
import { Icon } from "../ui/Icons";
import { auth, logout } from "../store/auth";

/**
 * A View mounts into a host and returns an unmount function
 */
export type View = (host: HTMLElement, params: Record<string, string>) => () => void;

/* ------------------ Small UI primitives ------------------ */

function currentPath() {
  return (location.hash || "#/home").replace(/^#/, "") || "/profile";
}

/** Map route path → human title. Adjust as you add pages. */
function pageTitleFromPath(path: string) {
  if (path.startsWith("/play")) return "Play";
  if (path.startsWith("/leaderboard")) return "Leaderboard";
  if (path.startsWith("/profile")) return "Profile";
  if (path.startsWith("/chats")) return "Chats";
  if (path.startsWith("/tournaments")) return "Tournaments";
  return "Transcendance";
}

/* ------------------ Nav link with icon ------------------ */

function NavLinkIcon(label: string, href: string, faClass: string) {
  const a = domElem("a", {
    class: "group flex items-center gap-3 text-gray-400 hover:text-teal-600",
    attributes: { href: `#${href}` },
  });

  const icon = domElem("i", { class: `w-5 h-5 fa-solid ${faClass}` });
  const text = domElem("span", { class: "text-lg font-semibold", text: label });
  a.append(icon, text);

  // initial active state
  const setActive = () => {
    const active = currentPath() === href;
    a.classList.toggle("text-teal-600", active);
    text.classList.toggle("font-semibold", active);
  };
  setActive();

  // reactive on hashchange
  const onHash = () => setActive();
  window.addEventListener("hashchange", onHash);

  // return element + unbind so sidebar can clean up listeners
  return { el: a, unbind: () => window.removeEventListener("hashchange", onHash) };
}

/* ------------------ User box (sidebar bottom) ------------------ */

const UserBox = () => {
  const box = domElem("div", { class: "mt-auto flex items-center gap-3 p-2 rounded-xl bg-gray-50" });
  const avatar = Avatar(null, 36);
  const name = domElem("div", { class: "text-sm" });
  box.append(avatar, name);
  return { box, avatar, name };
};

/**
 * Left sidebar with brand, nav, user and logout
 */
const SideBar = () => {
  const box = domElem("aside", { class: "w-64 bg-white border-r border-gray-100 p-4 flex flex-col gap-4" });

  const brandBox = domElem("div", { class: "flex flex-row items-center gap-3" });
  const brand = domElem("div", { class: "text-xl font-semibold text-teal-600", text: "Transcendance" });
  mount(brandBox, Icon("/ping-pong.png", "Transcendance logo"), brand);

  const nav = domElem("nav", { class: "flex flex-col gap-16 mt-40 ml-4 text-gray-400 text-xl" });
  const links = [
    NavLinkIcon("Play", "/play", "fa-gamepad"),
    NavLinkIcon("Leaderboard", "/home", "fa-house"),
    NavLinkIcon("Profile", "/profile", "fa-address-card"),
    NavLinkIcon("Chats", "/chats", "fa-comments"),
    NavLinkIcon("Tournaments", "/tournaments", "fa-trophy"),
  ];
  links.forEach((l) => nav.appendChild(l.el));

  const userBox = UserBox();
  const logoutBtn = Button("Logout", { variant: "danger", onClick: () => logout() });

  box.append(brandBox, nav, userBox.box, logoutBtn);

  // expose cleanup to remove hash listeners on links
  const unbind = () => links.forEach((l) => l.unbind());
  return { box, userBox, unbind };
};

/**
 * Top Bar
 */
const TopBar = () => {
  const wrap = domElem("div", { class: "sticky top-3 bg-emerald-100 text-2xl font-bold text-emerald-700 z-10" });
  const row = domElem("div", { class: "h-14 px-8 flex items-center justify-between" });

  // Left: dynamic title
  const title = domElem("div");
  const icon = domElem("i", { class: "fa-solid fa-bars mr-4" });
  const text = domElem("span", { text: pageTitleFromPath(currentPath()) });
  mount(title, icon, text);

  // Right: actions
  const actions = domElem("div", { class: "flex items-center gap-5 justify-between" });
  const searchBtn = IconButton("fa-magnifying-glass", "search icon", () => (location.hash = "/friends"));

  // Language toggle (persisted locally)
  const lang = (localStorage.getItem("lang") || "en").toLowerCase();
  const langBtn = IconButton(
    "fa-language",
    "Toggle language",
    () => {
      const next = (localStorage.getItem("lang") || "en").toLowerCase() === "en" ? "fr" : "en";
      localStorage.setItem("lang", next);
      document.documentElement.lang = next;
    },
    "Toggle language"
  );

  // User avatar (click → profile)
  const avatarBtn = ImageButton(auth.get().me?.avatar_url ?? "/user.png", "Avatar", {
    onClick: () => (location.hash = "/profile"),
    size: 32,
    variant: "circle",
  });

  actions.append(searchBtn, langBtn, avatarBtn);
  row.append(title, actions);
  wrap.appendChild(row);

  // Keep the title reactive to route changes
  const onHash = () => {
    title.textContent = pageTitleFromPath(currentPath());
  };
  window.addEventListener("hashchange", onHash);

  // expose hooks to update avatar & cleanup
  return {
    wrap,
    avatarBtn,
    unbind() {
      window.removeEventListener("hashchange", onHash);
    },
  };
};

/**
 * Main area with an outlet where child views render
 */
const MainArea = () => {
  const box = domElem("main", { class: "flex-1 flex flex-col overflow-auto" });
  const topBar = TopBar();
  const outlet = domElem("div", { class: "px-8 py-8" });
  mount(box, topBar.wrap, outlet);
  return { box, outlet, topBar };
};

/**
 * Subscribe UI to auth store; returns an unbind function
 */
const bindAuth = (avatarEl: HTMLDivElement) => {
  return bind(auth, (s) => {
    const url = s.me?.avatar_url ?? "/user.png";

    let img = avatarEl.querySelector("img") as HTMLImageElement | null;
    if (url) {
      if (!img) {
        img = document.createElement("img");
        img.className = "w-full h-full object-cover";
        avatarEl.appendChild(img);
      }
      img.src = url;
    } else if (img) {
      img.remove();
    }
  });
};

/**
 * AppShell : mounts the application (sidebar + main) and the child view.
 * Returns an unmount function that disposes subscriptions and child view.
 */
export function AppShell(child: View) {
  return (root: HTMLElement, params: Record<string, string>) => {
    root.className = "min-h-screen bg-emerald-100 text-slate-800";

    const layout = domElem("div", { class: "h-screen flex" });
    const sideBar = SideBar();
    const mainArea = MainArea();

    mount(layout, sideBar.box, mainArea.box);
    root.appendChild(layout);

    // Mount : set up bindings and child view
    // const unbindAuth = bindAuth(mainArea.topBar.userAvatar);
    const unmountChild = child(mainArea.outlet, params);

    // Unmount : clean up in reverse order
    return () => {
      //   unbindAuth();
      unmountChild();
    };
  };
}
// src/views/ChatsViews.ts
import { domElem, mount, bind } from "../ui/DomElement";
import * as Chats from "../store/chats";
import { Card } from "../ui/Card";
import { Button } from "../ui/Button";
import { auth } from "../store/auth";

const renderChatList = (chatList: HTMLDivElement, s: Chats.ChatsState) => {
  chatList.replaceChildren();
  const ul = domElem("ul", { class: "divide-y divide-gray-100" });
  s.list.forEach((c) => {
    const li = domElem("li", { class: "p-3 hover:bg-indigo-50 cursor-pointer" });
    const last = c.last_message ? `- ${c.last_message.body.slice(0, 30)}` : "";
    li.textContent = `${c.peer.pseudo}${last}`;
    li.addEventListener("click", () => {
      location.hash = `/chats/${c.id}`;
    });
    ul.appendChild(li);
  });
  chatList.appendChild(ul);
};

const loadPreviousMessages = (conversation: HTMLDivElement, chatId: number, s: Chats.ChatsState) => {
  const bucket = s.messages[chatId];
  if (!bucket || bucket.items.length === 0 || !bucket.loading) {
    Chats.loadMessages(chatId);
    const loadingEl = domElem("div", { class: "text-gray-400", text: "Loading messages..." });
    conversation.appendChild(loadingEl);
    return;
  }

  const wrap = domElem("div", { class: "flex flex-col h-[60vh]" });
  const scroll = domElem("div", { class: "flex-1 overflow-auto space-y-2 pr-2" });
  const meId = auth.get().me?.id;

  bucket.items.forEach((m) => {
    const bubble = domElem("div", { class: `max-w-[70%] px-3 py-2 rounded-xl ${m.author_id === meId ? "bg-indigo-100 self-end" : "bg-gray-100"}` });
    bubble.textContent = m.body;
    scroll.appendChild(bubble);
  });

  return { wrap, scroll };
};

const renderWritingBox = (chatId: number) => {
  const form = domElem("form", { class: "mt-3 flex gap-2" });
  const input = domElem("input", { class: "flex-1 px-3 py-2 rounded-xl border border-gray-200", attributes: { placeholder: "Type a message..." } });
  const sendBtn = Button("Send", { type: "submit" });

  form.addEventListener("submit", async (e) => {
    e.preventDefault();
    const body = (input as HTMLInputElement).value.trim();
    if (!body) return;
    sendBtn.setAttribute("disabled", "true");
    try {
      await Chats.sendMessage(chatId, body);
      (input as HTMLInputElement).value = "";
    } finally {
      sendBtn.removeAttribute("disabled");
    }
  });

  form.append(input, sendBtn);
  return { form, input, sendBtn };
};

const renderConversation = (conversation: HTMLDivElement, id: number, s: Chats.ChatsState) => {
  conversation.replaceChildren();
  const chatId = Number.isFinite(id) && id > 0 ? id : s.list[0]?.id;
  if (!chatId) {
    const noChat = domElem("div", { class: "text-gray-500", text: "No chat selected" });
    conversation.appendChild(noChat);
    return;
  }

  const previousMessages = loadPreviousMessages(conversation, chatId, s);
  if (previousMessages === undefined) return;

  const writingBox = renderWritingBox(chatId);
  mount(previousMessages.wrap, previousMessages.scroll, writingBox.form);
  conversation.appendChild(previousMessages.wrap);
};

const bindChatsView = (chatList: HTMLDivElement, conversation: HTMLDivElement, chatId: number) => {
  return bind(Chats.chats, (s) => {
    renderChatList(chatList, s);
    renderConversation(conversation, chatId, s);
  });
};

export const ChatsView = (root: HTMLElement, params: Record<string, string>) => {
  const title = domElem("h2", { class: "text-2xl font-semibold mb-4", text: "Chats" });
  const grid = domElem("div", { class: "grid grid-cols-1 md:grid-cols-[300px_1fr] gap-4" });

  const chatList = Card();
  const conversation = Card();

  mount(grid, chatList, conversation);
  mount(root, title, grid);
  Chats.loadMyChats();

  const unbindChatsView = bindChatsView(chatList, conversation, Number(params.id));

  return () => {
    unbindChatsView();
  };
};
// src/views/FriendsView.ts
import { domElem, mount, bind } from "../ui/DomElement";
import { Card } from "../ui/Card";
import { Avatar } from "../ui/Avatar";
import { Button } from "../ui/Button";
import * as Friends from "../store/friends";
import type { FriendRequest, PublicUser } from "../api/types";

const friendCard = (friend: PublicUser) => {
  const box = domElem("div", { class: "flex items-center gap-3" });
  const avatar = Avatar(friend.avatar_url);
  const pseudoBox = domElem("div", { class: "flex-1" });
  const pseudo = domElem("div", { class: "font-medium", text: friend.pseudo });
  const deleteBtn = Button("Remove", { variant: "danger", onClick: () => Friends.removeFriends(friend.id) });

  mount(pseudoBox, pseudo);
  return Card(mount(box, avatar, pseudoBox, deleteBtn));
};

const friendRequestCard = (r: FriendRequest) => {
  const box = domElem("div", { class: "flex items-center gap-3" });
  const request = domElem("div", { class: "text-sm flex-1", text: `Request #${r.id} from ${r.from_user_id} to ${r.to_user_id}` });
  const acceptBtn = Button("Accept", { onClick: () => Friends.acceptFriendRequest(r.id) });
  const declineBtn = Button("Decline", { variant: "ghost", onClick: () => Friends.declineFriendRequest(r.id) });

  return Card(mount(box, request, acceptBtn, declineBtn));
};

export const FriendsView = (root: HTMLElement) => {
  const list = domElem("div", { class: "grid md:grid-cols-2 gap-3" });
  const requests = domElem("div", { class: "mt-8" });

  mount(root, list, requests);
  Friends.loadFriends();
  Friends.loadFriendRequests();

  const unbindFriendsView = bind(Friends.friends, (s) => {
    list.replaceChildren();
    s.friends.forEach((f) => {
      const row = friendCard(f);
      list.appendChild(row);
    });

    requests.replaceChildren();
    const h = domElem("h3", { class: "text-lg font-semibold mb-2", text: "Requests" });
    requests.appendChild(h);
    s.requests.forEach((r) => {
      const row = friendRequestCard(r);
      requests.appendChild(row);
    });
  });

  return () => unbindFriendsView();
};
// src/views/HomeView.ts
import type { View } from "./AppShell";
import { domElem } from "../ui/DomElement";

export const HomeView: View = (root: HTMLElement) => {
  console.log("HomeView called");
  const h = domElem("h2", { class: "text-2xl font-semibold mb-2", text: "Welcome!" });
  const p = domElem("p", { class: "text-gray-600", text: "Queue up a match, check your friends, or jump into a chat." });
  root.append(h, p);
  return () => {};
};
// src/views/LoginView.ts
import { domElem, mount, bind } from "../ui/DomElement";
import { Card } from "../ui/Card";
import { Button } from "../ui/Button";
import { LabeledInput } from "../ui/Input";
import { Icon } from "../ui/Icons";
import { auth, register, login, verify2faLogin } from "../store/auth";
import { AuthAPI } from "../api/auth";

type Mode = "menu" | "login" | "register" | "twofa";

/* ----- Left Column building blocks ------ */

const OAuthButtons = () => {
  const box = domElem("div", { class: "flex flex-col gap-3" });
  const github = Button("Login with Github", { variant: "oauth", leading: Icon("/github_logo.svg", "github_logo"), onClick: () => AuthAPI.startGithubOAuth() });
  const google = Button("Login with Google", { variant: "oauth", leading: Icon("/google_logo.svg", "github_logo"), onClick: () => AuthAPI.startGoogleOAuth() });
  const fortyTwo = Button("Login with 42", { variant: "oauth", leading: Icon("/42_logo.svg", "github_logo"), onClick: () => AuthAPI.start42OAuth() });
  box.append(github, google, fortyTwo);

  return box;
};

const LeftMenu = (onShowLogin: () => void, onShowRegister: () => void) => {
  const box = domElem("div", { class: "flex flex-col gap-4" });
  const loginBtn = Button("Login", { variant: "login", onClick: onShowLogin });
  const registerBtn = Button("Register", { variant: "login", onClick: onShowRegister });
  const divider = domElem("div", { class: "h-px my-2" });
  box.append(registerBtn, loginBtn, divider, OAuthButtons());
  return box;
};

const RegisterForm = (onShowMenu: () => void) => {
  const emailField = LabeledInput("Email", { name: "email", placeholder: "you@example.com" });
  const pseudoField = LabeledInput("Pseudo", { name: "pseudo", placeholder: "CoolPlayer" });
  const passwordField = LabeledInput("Password", { type: "password", name: "password", placeholder: "•••••••" });

  const successOrError = domElem("div", { text: "" });
  const registerBtn = Button("Create account", { variant: "loginSmall", type: "submit" });
  const backbtn = Button("Back", { variant: "loginSmall", onClick: onShowMenu });

  const form = domElem("form", { class: "flex flex-col gap-3" });
  mount(form, emailField.labelWrapper, pseudoField.labelWrapper, passwordField.labelWrapper, successOrError, registerBtn, backbtn);

  form.addEventListener("submit", async (e) => {
    e.preventDefault();

    successOrError.textContent = "";
    successOrError.className = "";
    const email = emailField.input.value.trim();
    const pseudo = pseudoField.input.value.trim();
    const password = passwordField.input.value;
    try {
      await register(email, pseudo, password);
      successOrError.classList.add("text-sm", "text-green-600", "min-h-[1.25rem]");
      successOrError.textContent = `User ${pseudo} successfully created`;
    } catch (e: any) {
      successOrError.classList.add("text-sm", "text-rose-600", "min-h-[1.25rem]");
      successOrError.textContent = e?.message ?? "Registration failed";
    }
  });

  return { form, successOrError };
};

const LoginForm = (onShowMenu: () => void) => {
  const idField = LabeledInput("Email or Pseudo", { name: "id", placeholder: "CoolPlayer or example@mail.com" });
  const pwField = LabeledInput("Password", { type: "password", name: "pw", placeholder: "••••••••" });
  const err = domElem("div", { class: "text-sm text-rose-600 min-h-[1.25rem]" });
  const submit = Button("Sign in", { variant: "loginSmall", type: "submit" });
  const backbtn = Button("Back", { variant: "loginSmall", onClick: onShowMenu });

  const form = domElem("form", { class: "flex flex-col gap-3" });
  mount(form, idField.labelWrapper, pwField.labelWrapper, err, submit, backbtn);

  form.addEventListener("submit", async (e) => {
    e.preventDefault();
    err.textContent = "";
    submit.setAttribute("disabled", "true");
    submit.classList.add("opacity-60", "cursor-not-allowed");

    try {
      await login((idField.input as HTMLInputElement).value, (pwField.input as HTMLInputElement).value);
      if (!auth.get().twofaRequired) location.hash = "/home";
    } catch (e: any) {
      err.textContent = e?.message ?? "Login failed";
    } finally {
      submit.removeAttribute("disabled");
      submit.classList.remove("opacity-60", "cursor-not-allowed");
    }
  });

  return { form, err };
};

const TwofaForm = () => {
  const codeField = LabeledInput("2FA Code", { name: "code", placeholder: "123 456" });
  const submit = Button("Verify", { type: "submit" });
  const err = domElem("div", { class: "text-sm text-rose-600 min-h-[1.25rem]" });

  const form = domElem("form", { class: "flex flex-col gap-3 hidden" });
  mount(form, codeField.labelWrapper, err, submit);

  form.addEventListener("submit", async (e) => {
    e.preventDefault();
    err.textContent = "";
    try {
      await verify2faLogin((codeField.input as HTMLInputElement).value);
      location.hash = "/home";
    } catch (e: any) {
      err.textContent = e?.message ?? "Verification failed";
    }
  });

  return { form, err };
};

/* -------- Right Column -------- */

const RightPanel = () => {
  const box = domElem("div", { class: "h-full w-full relative overflow-hidden" });

  const header = domElem("div", { class: "p-8" });
  const title = domElem("h1", { class: "text-3xl md:text-4xl font-semibold text-white drop-shadow", text: "Transcendance" });
  const subtitle = domElem("p", { class: "text-slate-200 mt-2", text: "Play Pong, chat with friends, climb tournaments." });

  const imgWrap = domElem("div", { class: "absolute inset-0 z-10" });
  const img = domElem("img", {
    class: "w-full h-full object-cover opacity-30",
    attributes: { src: "/login_background_img.jpg", alt: "Pong Background" },
  });

  mount(imgWrap, img);
  mount(header, title, subtitle);
  mount(box, imgWrap, header);
  return box;
};

/* ------ Helpers ----- */
const show = (el: HTMLElement) => el.classList.remove("hidden");
const hide = (el: HTMLElement) => el.classList.add("hidden");

/* ---- Login View ----- */

export const LoginView = (root: HTMLElement) => {
  // Full-bleed split layout
  root.className = "min-h-screen grid md:grid-cols-[420px_1fr] bg-slate-900 text-slate-100";

  // LEFT: dark panel with menu/forms
  const left = domElem("div", { class: "min-h-screen bg-slate-950/60 backdrop-blur px-12 py-8 flex flex-col justify-center" });
  const leftInner = domElem("div"); // keeps spacing/polish consistent
  leftInner.classList.add("border-white/10", "text-slate-100");
  const header = domElem("div", { class: "mb-10 flex justify-center" });
  header.append(domElem("div", { class: "text-lg font-semibold", text: "Welcome" }));

  // Sections
  const menuSection = LeftMenu(
    () => setMode("login"),
    () => setMode("register")
  );

  const loginSection = domElem("div", { class: "flex flex-col gap-3 hidden" });
  const loginTitle = domElem("div", { class: "text-base font-semibold text-slate-200", text: "Login" });
  const loginForm = LoginForm(() => setMode("menu"));
  const loginOAuth = OAuthButtons();
  loginOAuth.classList.add("mt-2");
  mount(loginSection, loginTitle, loginForm.form, domElem("div", { class: "h-px bg-slate-700 my-2" }), loginOAuth);

  const twofaSection = domElem("div", { class: "flex flex-col gap-3 hidden" });
  const twofaTitle = domElem("div", { class: "text-sm font-semibold text-slate-200", text: "Two-Factor Authentication" });
  const twofaForm = TwofaForm();
  mount(twofaSection, twofaTitle, twofaForm.form);

  const registerSection = domElem("div", { class: "flex flex-col gap-3 hidden" });
  const registerTitle = domElem("div", { class: "text-base font-semibold text-slate-200", text: "Create your account" });
  const registerForm = RegisterForm(() => setMode("menu"));
  const registerOAuth = OAuthButtons();
  registerOAuth.classList.add("mt-2");
  mount(registerSection, registerTitle, registerForm.form, domElem("div", { class: "h-px bg-slate-700 my-2" }), registerOAuth);

  // Compose left card
  mount(leftInner, header, menuSection, loginSection, twofaSection, registerSection);
  left.appendChild(leftInner);

  // RIGHT: title + background image
  const right = RightPanel();

  // Mount to root
  mount(root, left, right);

  /* ---- Mode switching ---- */

  let mode: Mode = "menu";

  function setMode(next: Mode) {
    mode = next;

    // hide everything
    hide(menuSection);
    hide(loginSection);
    hide(twofaSection);
    hide(registerSection);

    // show one
    if (mode === "menu") show(menuSection);
    if (mode === "login") show(loginSection);
    if (mode === "twofa") show(twofaSection);
    if (mode === "register") show(registerSection);
  }

  // Initial state
  setMode("menu");

  // React to auth (2FA flips us into twofa when needed; else keep chosen tab)
  const stop = bind(auth, (s) => {
    if (s.twofaRequired) setMode("twofa");
  });

  return () => stop();
};
// src/views/ProfileView.ts
import { domElem, mount, bind } from "../ui/DomElement";
import { auth } from "../store/auth";
import { updateMe, uploadAvatar, deleteAvatar } from "../store/users";
import { Button } from "../ui/Button";
import { LabeledInput } from "../ui/Input";
import { Avatar } from "../ui/Avatar";

const TITLE_CLASSES = "text-teal-600 text-lg font-extrabold";
const SHARED_CLASSES = "rounded-lg bg-slate-50 backdrop-blur shadow-sm hover:shadow-md transition p-4 overflow-hidden";
const DEFAULT_AVATAR = "/user.png";

const CARD_CLASSES = "rounded-lg bg-slate-50 backdrop-blur shadow-sm hover:shadow-md transition overflow-hidden";

function Card(title: string, opts?: { minH?: string; contentClass?: string }) {
  const { minH = "min-h-28", contentClass = "" } = opts ?? {};

  const box = domElem("section", { class: CARD_CLASSES + " flex flex-col" });

  // Title docked top-left
  const header = domElem("h2", { class: TITLE_CLASSES + " p-4 pb-2", text: title });

  // Centered content slot (this is the magic)
  // grid + place-items-center centers both axes; min-h gives it breathing room
  const slot = domElem("div", {
    class: `h-full grid place-items-center ${minH} p-4 ${contentClass}`,
  });

  mount(box, header, slot);
  return { box, slot };
}

const MatchHistoryCard = () => {
  const { box, slot } = Card("Match History", { minH: "min-h-24" });

  const scores: { me: number; opp: number }[] = [
    { me: 1, opp: 2 },
    { me: 4, opp: 2 },
    { me: 5, opp: 3 },
    { me: 5, opp: 2 },
    { me: 1, opp: 6 },
    { me: 7, opp: 2 },
    { me: 1, opp: 2 },
  ];

  if (scores.length === 0) {
    const emptyMatchSquare = domElem("div", {
      class: "text-slate-400 text-lg",
      text: "No match to display yet.",
    });
    slot.append(emptyMatchSquare);
  } else {
    const row = domElem("div", { class: "flex flex-wrap items-center justify-center gap-4" });
    const scoreSquare = ({ me, opp }: { me: number; opp: number }) => {
      const win = me > opp;
      const colors = win ? "bg-emerald-600/20 border-emerald-500/40 text-emerald-600" : "bg-rose-200 border-rose-500/40 text-rose-600";

      const box = domElem("div", {
        class: `w-14 h-16 py-1 rounded-md border ${colors} flex flex-col items-center justify-around leading-none select-none font-bold`,
      });
      const topScore = domElem("div", { text: String(me) });
      const bottomScore = domElem("div", { text: String(opp) });
      mount(box, topScore, bottomScore);
      return box;
    };
    scores.forEach((s) => row.append(scoreSquare(s)));
    slot.append(row);
  }
  return box;
};

const WinrateCard = () => {
  const { box, slot } = Card("Winning Rate", { minH: "min-h-24" });

  const data = { won: 23, winrate: 0.53 };

  const wrap = domElem("div", { class: "flex flex-col text-center" });
  const gamesWon = domElem("div", { class: "font-extrabold text-2xl text-teal-600", text: `${data.won} games won` });
  const winRate = domElem("div", { class: "text-xl text-slate-400", text: `(${Math.round(data.winrate * 100)}%)` });

  mount(wrap, gamesWon, winRate);
  slot.append(wrap);
  return box;
};

const LongestStreakCard = () => {
  const { box, slot } = Card("Longest Streak", { minH: "min-h-24" });

  const data = { win: 4, loss: 3 };

  const wrap = domElem("div", {
    class: "flex flex-row justify-around items-center gap-12",
  });

  const winStreak = domElem("div", {
    class: "bg-emerald-600/20 border-emerald-500/40 text-emerald-600 w-10 h-14 py-1 rounded-md border font-bold flex justify-center items-center",
  });
  const wsText = domElem("div", { text: `${data.win}` });
  mount(winStreak, wsText);

  const loseStreak = domElem("div", {
    class: "bg-rose-200 border-rose-500/40 text-rose-600 w-10 h-14 py-1 rounded-md border font-bold flex justify-center items-center",
  });
  const lsText = domElem("div", { text: `${data.loss}` });
  mount(loseStreak, lsText);

  mount(wrap, winStreak, loseStreak);
  slot.append(wrap);
  return box;
};

const LeaderboardCard = () => {
  const { box, slot } = Card("LeaderBoard", { minH: "min-h-32" });

  const players: { name: string; score: number }[] = [
    { name: "Frank", score: 217 },
    { name: "Tom", score: 37 },
    { name: "Youri", score: 543 },
  ].sort((a, b) => b.score - a.score);

  if (players.length === 0) {
    const emptyLeaderBoard = domElem("div", {
      class: "text-slate-400 text-lg",
      text: "None has played yet.",
    });
    slot.append(emptyLeaderBoard);
  } else {
    const list = domElem("div", { class: "mx-auto w-full max-w-md flex flex-col gap-2" });

    players.forEach((p, i) => {
      const isFirst = i === 0;
      const isSecond = i === 1;

      const gold = "\u{1F947}";
      const silver = "\u{1F948}";
      const bronze = "\u{1F949}";

      const bgColor = isFirst ? "bg-amber-300/50" : isSecond ? "bg-slate-300/50" : "bg-amber-700/50";
      const bdColor = isFirst ? "border-amber-300" : isSecond ? "border-slate-300" : "border-amber-700";
      const textColor = isFirst ? "text-amber-500" : isSecond ? "text-slate-500" : "text-amber-800";
      const rankEmoji = isFirst ? gold : isSecond ? silver : bronze;
      const row = domElem("div", {
        class: `flex items-center justify-between h-18 px-3 rounded-xl border ${bgColor} ${bdColor} ${textColor}`,
      });
      const rank = domElem("div", { class: "text-center text-lg", text: rankEmoji });
      const name = domElem("div", { class: "truncate", text: p.name });
      const score = domElem("div", { class: "text-right font-semibold [font-variant-numeric:tabular-nums]", text: String(p.score) });
      mount(row, rank, name, score);
      list.appendChild(row);
    });
    slot.append(list);
  }
  return box;
};

const ProfileCard = () => {
  const user = {
    username: "PlayerOne",
    email: "player@example.com",
    avatar_url: "/user.png",
    twofa_enabled: false,
  };

  const box = domElem("div", { class: "rounded-lg bg-slate-50 backdrop-blur shadow-sm hover:shadow-md transition overflow-hidden flex flex-col" });

  // Top: gradient header (~1/3 height)
  const header = domElem("div", {
    class: "h-44 sm:h-60 bg-gradient-to-r from-teal-700 to-emerald-300 p-4 flex flex-col justify-center items-center gap-6",
  });
  const avatar = domElem("img", {
    class: "w-14 h-14 sm:w-16 sm:h-16 rounded-full ring-2 ring-white/70 object-cover",
    attributes: {
      src: user.avatar_url || DEFAULT_AVATAR,
      alt: user.username,
    },
  });
  const uname = domElem("div", {
    class: "text-white font-semibold text-lg sm:text-xl",
    text: user.username,
  });
  mount(header, avatar, uname);

  // Bottom: details + button pinned at bottom
  const body = domElem("div", { class: "p-6 flex-1 flex flex-col gap-4" });

  // Row: email
  const emailRow = domElem("div", {
    class: "flex items-center justify-between",
  });
  const emailLabel = domElem("span", {
    class: "text-lg text-zinc-400",
    text: "Email",
  });
  const emailValue = domElem("span", {
    class: "text-lg font-medium text-teal-600 truncate max-w-[60%] text-right",
    text: user.email,
  });
  mount(emailRow, emailLabel, emailValue);

  // Row: 2FA status
  const twofaRow = domElem("div", {
    class: "flex items-center justify-between",
  });
  const twofaLabel = domElem("span", {
    class: "text-lg text-zinc-400",
    text: "2FA",
  });
  const twofaBadge = domElem("span", {
    class:
      "inline-flex items-center px-2 py-0.5 rounded-full text-lg border " +
      (user.twofa_enabled ? "border-emerald-500/50 text-emerald-500 bg-emerald-600/15" : "border-rose-600 text-rose-600 bg-rose-200"),
    text: user.twofa_enabled ? "Enabled" : "Disabled",
  });
  mount(twofaRow, twofaLabel, twofaBadge);

  // Spacer so the button hugs the bottom
  const spacer = domElem("div", { class: "flex-1" });

  // Edit profile button
  const editBtn = domElem("button", {
    class: "text-gray-400 hover:text-teal-600 text-lg font-bold mouse-pointer",
    text: "Edit profile",
  });
  editBtn.append(domElem("i", { class: "ml-3 fa-solid fa-edit" }));

  // Hook up an action later:
  editBtn.addEventListener("click", () => {
    // open modal / navigate
    // router.go("/profile/edit")
  });
  mount(body, emailRow, twofaRow, spacer, editBtn);

  mount(box, header, body);
  return box;
};

const LatestMatchCard = () => {
  const { box, slot } = Card("Latest Match", { minH: "min-h-10" });

  const matchesPlayed = 1;

  if (matchesPlayed === 0) {
    const emptyLeaderBoard = domElem("div", {
      class: "text-slate-400 text-lg",
      text: "None has played yet.",
    });
    slot.appendChild(emptyLeaderBoard);
  } else {
    const wrap = domElem("div", { class: "mx-auto w-full max-w-md flex flex-col gap-2" });
    const latestMatch = {
      me: { name: "Player One", avatar: DEFAULT_AVATAR, score: 7 },
      opponent: { name: "Tom", avatar: DEFAULT_AVATAR, score: 3 },
    };
    const didWin = latestMatch.me.score > latestMatch.opponent.score;

    function row(player: { name: string; avatar: string; score: number }, badge?: HTMLElement) {
      const rowEl = domElem("div", { class: "flex justify-between items-center w-full" });

      const nameBox = domElem("div", { class: "flex items-center gap-5" });
      const avatar = domElem("img", {
        class: "w-8 h-8 rounded-full object-cover",
        attributes: {
          src: player.avatar,
          alt: player.name,
        },
      });
      const name = domElem("div", { class: "truncate text-teal-600 font-medium", text: player.name });
      mount(nameBox, avatar, name);

      const scoreBox = domElem("div", { class: "flex items-center gap-2" });
      const score = domElem("div", { class: "w-6 text-right font-semibold [font-variant-numeric:tabular-nums]", text: String(player.score) });
      scoreBox.append(score, badge ?? domElem("div", { class: "w-5 h-5" }));

      mount(rowEl, nameBox, scoreBox);
      return rowEl;
    }
    const badge = domElem("div", {
      class: "w-5 h-5 rounded text-xs flex items-center justify-center " + (didWin ? "bg-emerald-600/70 text-white" : "bg-rose-600/70 text-white"),
      text: didWin ? "W" : "L",
    });

    const meRow = row(latestMatch.me, badge);
    const oppRow = row(latestMatch.opponent);
    mount(wrap, meRow, oppRow);
    slot.append(wrap);
  }

  return box;
};

export const ProfileView = (root: HTMLElement) => {
  const matchHistory = MatchHistoryCard();
  const winRate = WinrateCard();
  const longestStreak = LongestStreakCard();
  const leaderBoard = LeaderboardCard();
  const profileCard = ProfileCard();
  const latestMatch = LatestMatchCard();

  root.className = "grid grid-cols-8 grid-rows-5 gap-3 px-8 py-12";

  matchHistory.className += " col-span-4 row-span-1";
  profileCard.className += " col-span-4 row-span-4";
  winRate.className += " col-span-2 row-span-2";
  longestStreak.className += " col-span-2 row-span-2";
  leaderBoard.className += " col-span-4 row-span-2";
  latestMatch.className += " col-span-4 row-span-1";

  root.replaceChildren(matchHistory, profileCard, winRate, longestStreak, leaderBoard, latestMatch);
};
//   const card = Card();
//   const avZone = domElem("div", { class: "flex items-center gap-4" });
//   const form = domElem("form", { class: "mt-4 flex items-end gap-3" });
//   const pseudo = LabeledInput("Pseudo");
//   const avatarUrl = LabeledInput("Avatar URL");
//   const save = Button("Save", { type: "submit" });
//   const del = Button("Remove avatar", { variant: "ghost", onClick: () => deleteAvatar() });
//   form.addEventListener("submit", async (e) => {
//     e.preventDefault();
//     const p = (pseudo.input as HTMLInputElement).value.trim();
//     const url = (avatarUrl.input as HTMLInputElement).value.trim();
//     if (p) await updateMe({ pseudo: p });
//     if (url) await uploadAvatar(url);
//   });
//   mount(card, avZone, form);
//   mount(form, pseudo.labelWrapper, avatarUrl.labelWrapper, save, del);
//   const unbind = bind(auth, (s) => {
//     avZone.replaceChildren(Avatar(s.me?.avatar_url ?? null, 64), domElem("div", { class: "font-medium", text: s.me?.pseudo ?? "..." }));
//     pseudo.input.value = s.me?.pseudo ?? "";
//     avatarUrl.input.value = s.me?.avatar_url ?? "";
//   });
//   root.append(card);
//   return () => unbind();
// src/views/TournamentView.ts
import { domElem, mount, bind } from "../ui/DomElement";
import * as tournamentStore from "../store/tournaments";
import { Card } from "../ui/Card";
import { Button } from "../ui/Button";
import type { Tournament } from "../api/types";

const createTournamentCard = (t: Tournament) => {
  const box = domElem("div");
  const title = domElem("div", { class: "font-semibold", text: t.title });
  const status = domElem("div", { class: "text-xs text-gray-500 mb-2", text: `Status: ${t.status}` });
  const detailsBtn = Button("Details", { variant: "ghost", onClick: () => alert(`Open details for #${t.id}`) });

  const tournamentCard = mount(box, title, status, detailsBtn);
  return Card(tournamentCard);
};

export const TournamentsView = (root: HTMLElement) => {
  const list = domElem("div", { class: "grid md:grid-cols-2 gap-3" });

  const bar = domElem("div", { class: "mb-3 flex gap-2" });
  const newBtn = Button("New Tournament", {
    onClick: async () => {
      const title = prompt("Title ?");
      if (!title) return;
      await tournamentStore.createTournament(title, null, 8);
      await tournamentStore.listTournaments();
    },
  });
  bar.appendChild(newBtn);

  mount(root, bar, list);
  tournamentStore.listTournaments();

  const unbindTournament = bind(tournamentStore.tournaments, (s) => {
    list.replaceChildren();
    s.listing.items.forEach((t) => {
      const card = createTournamentCard(t);
      list.appendChild(card);
    });
  });

  return () => unbindTournament();
};
